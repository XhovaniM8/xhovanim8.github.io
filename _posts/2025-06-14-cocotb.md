---
title: "cocotb CPU Verification: Complete Linux Tutorial for FPGA Engineers"
date: 2025-06-21 10:00:00 +0000
categories: [guide, fpga, verification]
tags: [cocotb, cpu-verification, fpga, verilog, python, linux, hardware-verification, risc-v, testbench, simulation]
excerpt: "Learn how to verify a CPU design using cocotb on Linux. This step-by-step tutorial covers environment setup, writing Python testbenches, and advanced verification techniques for processor designs."
---

# cocotb CPU Verification: Complete Linux Tutorial for FPGA Engineers

Verifying a CPU design is one of the most challenging tasks in digital design. Traditional SystemVerilog testbenches can be verbose and difficult to maintain. Enter **cocotb** — a Python-based verification framework that brings modern software development practices to hardware verification. In this comprehensive tutorial, you'll learn how to set up a Linux environment for cocotb and verify a simple RISC-style CPU from scratch.

## Why Use cocotb for CPU Verification?

CPU verification demands flexibility that traditional HDL testbenches struggle to provide. cocotb offers several advantages for processor verification:

- **Instruction generation**: Use Python to generate random or directed instruction sequences
- **Reference models**: Implement golden models in Python for comparison
- **Coverage analysis**: Leverage Python libraries for sophisticated coverage metrics
- **Debug capabilities**: Access Python's rich debugging ecosystem
- **Test automation**: Integrate with pytest for organized test suites

## Setting Up Your Linux Environment

### Prerequisites

This tutorial assumes you're running Ubuntu 22.04 or later, though the instructions work on most Linux distributions with minor modifications.

### Step 1: Install System Dependencies

Open your terminal and install the required packages:

```bash
# Update package lists
sudo apt update

# Install Python and pip
sudo apt install python3 python3-pip python3-venv

# Install Icarus Verilog (open-source Verilog simulator)
sudo apt install iverilog

# Install GTKWave for waveform viewing
sudo apt install gtkwave

# Install make and build essentials
sudo apt install build-essential
```

### Step 2: Create a Virtual Environment

Using a virtual environment keeps your project dependencies isolated:

```bash
# Create project directory
mkdir ~/cpu_verification
cd ~/cpu_verification

# Create virtual environment
python3 -m venv venv

# Activate the virtual environment
source venv/bin/activate

# Verify Python is using the virtual environment
which python3
```

### Step 3: Install cocotb and Dependencies

```bash
# Install cocotb
pip install cocotb

# Install additional useful packages
pip install cocotb-bus numpy pytest

# Verify installation
cocotb-config --version
```

### Step 4: Configure Your Shell (Optional)

Add these aliases to your `~/.bashrc` for convenience:

```bash
# Add to ~/.bashrc
alias activate-cocotb='source ~/cpu_verification/venv/bin/activate'
alias run-tests='make clean && make'

# Reload bashrc
source ~/.bashrc
```

## Project Structure

Create the following directory structure for your CPU verification project:

```bash
mkdir -p rtl tests tb_utils
touch rtl/simple_cpu.v tests/test_cpu.py tb_utils/__init__.py Makefile
```

Your project should look like this:

```
cpu_verification/
├── rtl/
│   └── simple_cpu.v
├── tests/
│   ├── __init__.py
│   └── test_cpu.py
├── tb_utils/
│   ├── __init__.py
│   ├── cpu_model.py
│   └── instruction_generator.py
├── Makefile
└── venv/
```

## The CPU Design Under Test

Let's create a simple 8-bit RISC-style CPU with basic operations. This design is intentionally simple for learning purposes.

### CPU Specification

- 8-bit data width
- 4 general-purpose registers (R0-R3)
- Simple instruction set: ADD, SUB, LOAD, STORE, JUMP, BRANCH
- 8-bit instruction encoding

### RTL Implementation (simple_cpu.v)

```verilog
module simple_cpu #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 8,
    parameter REG_COUNT = 4
)(
    input  wire                    clk,
    input  wire                    rst_n,
    input  wire                    enable,
    
    // Instruction interface
    input  wire [7:0]              instruction,
    input  wire                    instr_valid,
    output reg                     instr_ready,
    
    // Memory interface
    output reg  [ADDR_WIDTH-1:0]   mem_addr,
    output reg  [DATA_WIDTH-1:0]   mem_wdata,
    input  wire [DATA_WIDTH-1:0]   mem_rdata,
    output reg                     mem_we,
    output reg                     mem_re,
    
    // Status outputs
    output reg                     halted,
    output reg  [DATA_WIDTH-1:0]   result,
    output reg                     result_valid,
    output reg  [1:0]              current_reg
);

// Instruction encoding
// [7:6] = opcode, [5:4] = dest reg, [3:2] = src1 reg, [1:0] = src2 reg/immediate

localparam OP_ADD   = 2'b00;
localparam OP_SUB   = 2'b01;
localparam OP_LOAD  = 2'b10;
localparam OP_STORE = 2'b11;

// CPU states
localparam STATE_IDLE    = 3'b000;
localparam STATE_FETCH   = 3'b001;
localparam STATE_DECODE  = 3'b010;
localparam STATE_EXECUTE = 3'b011;
localparam STATE_MEMORY  = 3'b100;
localparam STATE_WRITEBACK = 3'b101;

reg [2:0] state, next_state;
reg [DATA_WIDTH-1:0] registers [0:REG_COUNT-1];
reg [7:0] current_instr;
reg [1:0] opcode, rd, rs1, rs2;
reg [DATA_WIDTH-1:0] alu_result;
reg [DATA_WIDTH-1:0] operand_a, operand_b;

// State machine
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= STATE_IDLE;
    end else begin
        state <= next_state;
    end
end

// Next state logic
always @(*) begin
    next_state = state;
    case (state)
        STATE_IDLE: begin
            if (enable && instr_valid)
                next_state = STATE_FETCH;
        end
        STATE_FETCH: begin
            next_state = STATE_DECODE;
        end
        STATE_DECODE: begin
            next_state = STATE_EXECUTE;
        end
        STATE_EXECUTE: begin
            if (opcode == OP_LOAD || opcode == OP_STORE)
                next_state = STATE_MEMORY;
            else
                next_state = STATE_WRITEBACK;
        end
        STATE_MEMORY: begin
            next_state = STATE_WRITEBACK;
        end
        STATE_WRITEBACK: begin
            next_state = STATE_IDLE;
        end
        default: next_state = STATE_IDLE;
    endcase
end

// Datapath
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        // Reset all registers
        registers[0] <= 8'h00;
        registers[1] <= 8'h00;
        registers[2] <= 8'h00;
        registers[3] <= 8'h00;
        current_instr <= 8'h00;
        opcode <= 2'b00;
        rd <= 2'b00;
        rs1 <= 2'b00;
        rs2 <= 2'b00;
        alu_result <= 8'h00;
        operand_a <= 8'h00;
        operand_b <= 8'h00;
        halted <= 1'b0;
        result <= 8'h00;
        result_valid <= 1'b0;
        instr_ready <= 1'b1;
        mem_addr <= 8'h00;
        mem_wdata <= 8'h00;
        mem_we <= 1'b0;
        mem_re <= 1'b0;
        current_reg <= 2'b00;
    end else begin
        // Default values
        result_valid <= 1'b0;
        mem_we <= 1'b0;
        mem_re <= 1'b0;
        
        case (state)
            STATE_IDLE: begin
                instr_ready <= 1'b1;
                if (enable && instr_valid) begin
                    current_instr <= instruction;
                    instr_ready <= 1'b0;
                end
            end
            
            STATE_FETCH: begin
                // Decode instruction fields
                opcode <= current_instr[7:6];
                rd <= current_instr[5:4];
                rs1 <= current_instr[3:2];
                rs2 <= current_instr[1:0];
            end
            
            STATE_DECODE: begin
                // Read operands from register file
                operand_a <= registers[rs1];
                operand_b <= registers[rs2];
                current_reg <= rd;
            end
            
            STATE_EXECUTE: begin
                case (opcode)
                    OP_ADD: alu_result <= operand_a + operand_b;
                    OP_SUB: alu_result <= operand_a - operand_b;
                    OP_LOAD: begin
                        mem_addr <= operand_a;
                        mem_re <= 1'b1;
                    end
                    OP_STORE: begin
                        mem_addr <= operand_a;
                        mem_wdata <= operand_b;
                        mem_we <= 1'b1;
                    end
                endcase
            end
            
            STATE_MEMORY: begin
                if (opcode == OP_LOAD) begin
                    alu_result <= mem_rdata;
                end
            end
            
            STATE_WRITEBACK: begin
                if (opcode != OP_STORE) begin
                    registers[rd] <= alu_result;
                    result <= alu_result;
                    result_valid <= 1'b1;
                end
            end
        endcase
    end
end

endmodule
```

## Writing cocotb Testbenches

Now let's create comprehensive testbenches to verify our CPU.

### CPU Reference Model (tb_utils/cpu_model.py)

First, create a Python reference model:

```python
"""
Reference model for the simple CPU.
Used to generate expected results for verification.
"""

class CPUModel:
    """Golden reference model for CPU verification"""
    
    OP_ADD = 0b00
    OP_SUB = 0b01
    OP_LOAD = 0b10
    OP_STORE = 0b11
    
    def __init__(self, num_registers=4, data_width=8):
        self.num_registers = num_registers
        self.data_width = data_width
        self.max_val = (1 << data_width) - 1
        self.registers = [0] * num_registers
        self.memory = {}
        
    def reset(self):
        """Reset CPU state"""
        self.registers = [0] * self.num_registers
        self.memory = {}
        
    def execute(self, instruction):
        """
        Execute a single instruction and return the result.
        
        Args:
            instruction: 8-bit instruction word
            
        Returns:
            tuple: (result, result_valid, mem_write_info)
        """
        opcode = (instruction >> 6) & 0x03
        rd = (instruction >> 4) & 0x03
        rs1 = (instruction >> 2) & 0x03
        rs2 = instruction & 0x03
        
        result = 0
        result_valid = False
        mem_write = None
        
        if opcode == self.OP_ADD:
            result = (self.registers[rs1] + self.registers[rs2]) & self.max_val
            self.registers[rd] = result
            result_valid = True
            
        elif opcode == self.OP_SUB:
            result = (self.registers[rs1] - self.registers[rs2]) & self.max_val
            self.registers[rd] = result
            result_valid = True
            
        elif opcode == self.OP_LOAD:
            addr = self.registers[rs1]
            result = self.memory.get(addr, 0)
            self.registers[rd] = result
            result_valid = True
            
        elif opcode == self.OP_STORE:
            addr = self.registers[rs1]
            data = self.registers[rs2]
            self.memory[addr] = data
            mem_write = (addr, data)
            result_valid = False
            
        return result, result_valid, mem_write
    
    def set_register(self, reg_num, value):
        """Set a register value (for test setup)"""
        if 0 <= reg_num < self.num_registers:
            self.registers[reg_num] = value & self.max_val
            
    def get_register(self, reg_num):
        """Get a register value"""
        if 0 <= reg_num < self.num_registers:
            return self.registers[reg_num]
        return 0
    
    def set_memory(self, addr, value):
        """Set a memory location (for test setup)"""
        self.memory[addr & self.max_val] = value & self.max_val
        
    @staticmethod
    def encode_instruction(opcode, rd, rs1, rs2):
        """Encode an instruction from its components"""
        return ((opcode & 0x03) << 6) | ((rd & 0x03) << 4) | ((rs1 & 0x03) << 2) | (rs2 & 0x03)
```

### Instruction Generator (tb_utils/instruction_generator.py)

```python
"""
Instruction generator for CPU verification.
Generates random and directed test sequences.
"""

import random
from .cpu_model import CPUModel

class InstructionGenerator:
    """Generate instruction sequences for testing"""
    
    def __init__(self, seed=None):
        if seed is not None:
            random.seed(seed)
            
    def random_instruction(self):
        """Generate a random instruction"""
        opcode = random.randint(0, 3)
        rd = random.randint(0, 3)
        rs1 = random.randint(0, 3)
        rs2 = random.randint(0, 3)
        return CPUModel.encode_instruction(opcode, rd, rs1, rs2)
    
    def random_sequence(self, length=10):
        """Generate a sequence of random instructions"""
        return [self.random_instruction() for _ in range(length)]
    
    def alu_stress_test(self, num_ops=50):
        """Generate ALU-heavy instruction sequence"""
        instructions = []
        for _ in range(num_ops):
            opcode = random.choice([CPUModel.OP_ADD, CPUModel.OP_SUB])
            rd = random.randint(0, 3)
            rs1 = random.randint(0, 3)
            rs2 = random.randint(0, 3)
            instructions.append(CPUModel.encode_instruction(opcode, rd, rs1, rs2))
        return instructions
    
    def memory_test_sequence(self):
        """Generate memory operation test sequence"""
        instructions = []
        
        # Store to various addresses, then load back
        for i in range(4):
            # Store R[i] to address in R0
            instructions.append(CPUModel.encode_instruction(
                CPUModel.OP_STORE, 0, 0, i
            ))
            
        for i in range(4):
            # Load from address in R0 to R[i]
            instructions.append(CPUModel.encode_instruction(
                CPUModel.OP_LOAD, i, 0, 0
            ))
            
        return instructions
    
    def register_dependency_test(self):
        """Test read-after-write dependencies"""
        return [
            # R1 = R0 + R0
            CPUModel.encode_instruction(CPUModel.OP_ADD, 1, 0, 0),
            # R2 = R1 + R1 (depends on previous result)
            CPUModel.encode_instruction(CPUModel.OP_ADD, 2, 1, 1),
            # R3 = R2 - R1 (depends on both previous results)
            CPUModel.encode_instruction(CPUModel.OP_SUB, 3, 2, 1),
        ]
```

### Main Test File (tests/test_cpu.py)

```python
"""
cocotb testbench for simple CPU verification.
"""

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, FallingEdge, Timer, ClockCycles
from cocotb.result import TestFailure

import sys
import os

# Add tb_utils to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from tb_utils.cpu_model import CPUModel
from tb_utils.instruction_generator import InstructionGenerator


class CPUTestbench:
    """Reusable testbench infrastructure for CPU verification"""
    
    def __init__(self, dut):
        self.dut = dut
        self.model = CPUModel()
        self.clock_period = 10  # ns
        
    async def setup(self):
        """Initialize the testbench"""
        # Start clock
        cocotb.start_soon(Clock(self.dut.clk, self.clock_period, units="ns").start())
        
        # Initialize inputs
        self.dut.rst_n.value = 0
        self.dut.enable.value = 0
        self.dut.instruction.value = 0
        self.dut.instr_valid.value = 0
        self.dut.mem_rdata.value = 0
        
        # Reset sequence
        await ClockCycles(self.dut.clk, 5)
        self.dut.rst_n.value = 1
        await ClockCycles(self.dut.clk, 2)
        
        # Reset model
        self.model.reset()
        
        cocotb.log.info("Testbench setup complete")
        
    async def execute_instruction(self, instruction):
        """Execute a single instruction and wait for completion"""
        
        # Wait for CPU to be ready
        while not self.dut.instr_ready.value:
            await RisingEdge(self.dut.clk)
            
        # Send instruction
        self.dut.enable.value = 1
        self.dut.instruction.value = instruction
        self.dut.instr_valid.value = 1
        
        await RisingEdge(self.dut.clk)
        self.dut.instr_valid.value = 0
        
        # Wait for execution to complete
        timeout_cycles = 20
        for _ in range(timeout_cycles):
            await RisingEdge(self.dut.clk)
            
            # Handle memory reads
            if self.dut.mem_re.value:
                addr = int(self.dut.mem_addr.value)
                self.dut.mem_rdata.value = self.model.memory.get(addr, 0)
                
            if self.dut.instr_ready.value:
                break
        else:
            raise TestFailure(f"Instruction execution timed out after {timeout_cycles} cycles")
            
        return int(self.dut.result.value) if self.dut.result_valid.value else None
    
    async def verify_instruction(self, instruction):
        """Execute instruction on both DUT and model, compare results"""
        
        # Execute on model
        expected_result, expected_valid, mem_write = self.model.execute(instruction)
        
        # Execute on DUT
        dut_result = await self.execute_instruction(instruction)
        
        # Compare results
        if expected_valid:
            if dut_result != expected_result:
                opcode = (instruction >> 6) & 0x03
                rd = (instruction >> 4) & 0x03
                rs1 = (instruction >> 2) & 0x03
                rs2 = instruction & 0x03
                raise TestFailure(
                    f"Result mismatch for instruction 0x{instruction:02X} "
                    f"(op={opcode}, rd={rd}, rs1={rs1}, rs2={rs2}): "
                    f"expected {expected_result}, got {dut_result}"
                )
                
        cocotb.log.debug(f"Instruction 0x{instruction:02X} passed: result={dut_result}")
        return True
    
    async def load_registers(self, values):
        """Load initial values into registers using ADD instructions"""
        for reg, value in enumerate(values[:4]):
            self.model.set_register(reg, value)
            # We'd need a special mechanism to load registers in actual hardware
            # For now, we'll modify the DUT directly (not synthesizable, but useful for testing)
            
    def check_registers(self):
        """Verify all registers match between DUT and model"""
        for i in range(4):
            # In a real testbench, you'd read from DUT registers
            model_val = self.model.get_register(i)
            cocotb.log.info(f"Register R{i}: model={model_val}")


# Individual test cases

@cocotb.test()
async def test_reset(dut):
    """Test CPU reset behavior"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    # Verify reset state
    assert dut.halted.value == 0, "CPU should not be halted after reset"
    assert dut.instr_ready.value == 1, "CPU should be ready for instructions"
    assert dut.result_valid.value == 0, "No valid result after reset"
    
    cocotb.log.info("Reset test passed")


@cocotb.test()
async def test_add_basic(dut):
    """Test basic ADD instruction"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    # Test ADD R1, R0, R0 (R1 = R0 + R0 = 0)
    instr = CPUModel.encode_instruction(CPUModel.OP_ADD, 1, 0, 0)
    await tb.verify_instruction(instr)
    
    cocotb.log.info("Basic ADD test passed")


@cocotb.test()
async def test_sub_basic(dut):
    """Test basic SUB instruction"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    # Test SUB R2, R0, R1
    instr = CPUModel.encode_instruction(CPUModel.OP_SUB, 2, 0, 1)
    await tb.verify_instruction(instr)
    
    cocotb.log.info("Basic SUB test passed")


@cocotb.test()
async def test_alu_sequence(dut):
    """Test a sequence of ALU operations"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    gen = InstructionGenerator(seed=42)
    instructions = gen.alu_stress_test(num_ops=20)
    
    for i, instr in enumerate(instructions):
        await tb.verify_instruction(instr)
        if (i + 1) % 5 == 0:
            cocotb.log.info(f"Completed {i + 1} ALU operations")
            
    cocotb.log.info("ALU sequence test passed")


@cocotb.test()
async def test_register_dependencies(dut):
    """Test read-after-write register dependencies"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    gen = InstructionGenerator()
    instructions = gen.register_dependency_test()
    
    for instr in instructions:
        await tb.verify_instruction(instr)
        
    cocotb.log.info("Register dependency test passed")


@cocotb.test()
async def test_random_instructions(dut):
    """Random instruction test"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    gen = InstructionGenerator(seed=12345)
    
    for i in range(50):
        instr = gen.random_instruction()
        try:
            await tb.verify_instruction(instr)
        except TestFailure as e:
            cocotb.log.error(f"Failed on instruction {i}: {e}")
            raise
            
    cocotb.log.info("Random instruction test passed (50 instructions)")


@cocotb.test()
async def test_back_to_back_operations(dut):
    """Test rapid back-to-back instruction execution"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    # Quick succession of operations
    for i in range(10):
        instr = CPUModel.encode_instruction(
            CPUModel.OP_ADD, 
            i % 4,  # rd
            (i + 1) % 4,  # rs1
            (i + 2) % 4   # rs2
        )
        await tb.verify_instruction(instr)
        
    cocotb.log.info("Back-to-back operations test passed")


@cocotb.test()
async def test_overflow_behavior(dut):
    """Test arithmetic overflow handling"""
    tb = CPUTestbench(dut)
    await tb.setup()
    
    # Set up registers with values that will overflow
    # First, build up a large value through additions
    for _ in range(50):
        instr = CPUModel.encode_instruction(CPUModel.OP_ADD, 0, 0, 0)
        await tb.verify_instruction(instr)
        
    # The model should handle overflow correctly (wrap around)
    cocotb.log.info("Overflow behavior test passed")
```

### tb_utils/__init__.py

```python
"""Test utilities package"""
from .cpu_model import CPUModel
from .instruction_generator import InstructionGenerator
```

### Makefile

```makefile
# Makefile for cocotb CPU verification

# Simulator selection
SIM ?= icarus
TOPLEVEL_LANG ?= verilog

# Source files
VERILOG_SOURCES += $(PWD)/rtl/simple_cpu.v

# Top-level module
TOPLEVEL = simple_cpu

# Python test module
MODULE = tests.test_cpu

# Include cocotb's make rules
include $(shell cocotb-config --makefiles)/Makefile.sim

# Waveform generation
PLUSARGS += +vcd

# Custom targets
.PHONY: waves clean-all

waves: $(TOPLEVEL).vcd
	gtkwave $(TOPLEVEL).vcd &

clean-all: clean
	rm -rf __pycache__ tests/__pycache__ tb_utils/__pycache__
	rm -f *.vcd
```

## Running the Verification

### Execute All Tests

```bash
# Make sure virtual environment is active
source venv/bin/activate

# Run all tests
make

# View results
cat results.xml
```

### Run Specific Tests

```bash
# Run only the reset test
make TESTCASE=test_reset

# Run only ALU tests
make TESTCASE=test_alu_sequence
```

### Generate and View Waveforms

```bash
# Generate VCD file
make SIM_ARGS="+vcd"

# Open in GTKWave
gtkwave simple_cpu.vcd
```

## Advanced Verification Techniques

### Coverage Collection

Create a coverage collector to track which operations have been tested:

```python
# tb_utils/coverage.py

class FunctionalCoverage:
    """Track functional coverage points"""
    
    def __init__(self):
        self.opcode_coverage = {
            'ADD': False,
            'SUB': False,
            'LOAD': False,
            'STORE': False
        }
        self.register_coverage = [[False]*4 for _ in range(4)]  # [src][dst]
        self.edge_cases = {
            'overflow': False,
            'underflow': False,
            'zero_result': False,
            'max_result': False
        }
        
    def sample_instruction(self, instruction, result):
        opcode = (instruction >> 6) & 0x03
        rd = (instruction >> 4) & 0x03
        rs1 = (instruction >> 2) & 0x03
        
        # Track opcode coverage
        op_names = ['ADD', 'SUB', 'LOAD', 'STORE']
        self.opcode_coverage[op_names[opcode]] = True
        
        # Track register combinations
        self.register_coverage[rs1][rd] = True
        
        # Track edge cases
        if result == 0:
            self.edge_cases['zero_result'] = True
        if result == 255:
            self.edge_cases['max_result'] = True
            
    def report(self):
        print("\n=== Coverage Report ===")
        print(f"Opcode coverage: {sum(self.opcode_coverage.values())}/4")
        for op, hit in self.opcode_coverage.items():
            print(f"  {op}: {'✓' if hit else '✗'}")
            
        reg_hits = sum(sum(row) for row in self.register_coverage)
        print(f"\nRegister combinations: {reg_hits}/16")
        
        edge_hits = sum(self.edge_cases.values())
        print(f"\nEdge cases: {edge_hits}/{len(self.edge_cases)}")
        for case, hit in self.edge_cases.items():
            print(f"  {case}: {'✓' if hit else '✗'}")
```

### Constrained Random Verification

```python
# tb_utils/constraints.py

import random

class ConstrainedRandom:
    """Generate constrained random test vectors"""
    
    def __init__(self, seed=None):
        self.rng = random.Random(seed)
        
    def weighted_opcode(self, weights=None):
        """Select opcode with weighted probability"""
        if weights is None:
            weights = {
                'ADD': 40,
                'SUB': 40,
                'LOAD': 10,
                'STORE': 10
            }
        opcodes = list(weights.keys())
        probs = list(weights.values())
        return self.rng.choices(opcodes, weights=probs)[0]
    
    def biased_register(self, bias_toward=None):
        """Select register with optional bias"""
        if bias_toward is not None and self.rng.random() < 0.7:
            return bias_toward
        return self.rng.randint(0, 3)
```

## Debugging Tips for Linux

### Using Python Debugger

Insert breakpoints in your test:

```python
@cocotb.test()
async def test_debug_example(dut):
    tb = CPUTestbench(dut)
    await tb.setup()
    
    # Set breakpoint
    import pdb; pdb.set_trace()
    
    # Continue with test...
```

### Viewing Signals in Terminal

```python
async def print_cpu_state(dut):
    """Print current CPU state for debugging"""
    print(f"""
    === CPU State ===
    State: {dut.state.value}
    Instruction: 0x{int(dut.current_instr.value):02X}
    Opcode: {dut.opcode.value}
    Result: {dut.result.value}
    Result Valid: {dut.result_valid.value}
    """)
```

### GTKWave Integration

Create a save file for common signal views:

```bash
# Create signals.gtkw
gtkwave -S signals.tcl simple_cpu.vcd
```

## Common Issues and Solutions

| Issue | Solution |
|-------|----------|
| `ModuleNotFoundError: cocotb` | Activate virtual environment: `source venv/bin/activate` |
| Simulator not found | Install Icarus: `sudo apt install iverilog` |
| Permission denied on Makefile | Run `chmod +x` on scripts |
| VCD file not generated | Add `+vcd` to PLUSARGS in Makefile |
| Tests hang indefinitely | Add timeout to wait conditions |

## Conclusion

You've now learned how to set up a complete CPU verification environment on Linux using cocotb. This approach combines Python's flexibility with hardware verification rigor, enabling you to write maintainable, powerful testbenches. The techniques covered here scale from simple designs to complex processor implementations.

Key takeaways:
- cocotb enables Python-based hardware verification
- Reference models catch design bugs early
- Constrained random testing improves coverage
- Linux provides excellent tool support for FPGA verification

For your next steps, consider extending this framework with formal verification integration, adding UVM-style sequences, or implementing more sophisticated coverage models.

## Resources

- [cocotb Documentation](https://docs.cocotb.org/)
- [Icarus Verilog](http://iverilog.icarus.com/)
- [GTKWave Manual](http://gtkwave.sourceforge.net/)
- [Python asyncio Tutorial](https://docs.python.org/3/library/asyncio.html)
