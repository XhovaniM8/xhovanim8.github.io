---
title: "Advent of FPGA 2025: Setup and Participation Guide"
date: 2025-12-19
author: Xhovani Mali
categories: [fpga, challenge]
tags: [fpga, advent-of-code, hardcaml, verilog, systemverilog, jane-street, hardware-design, rtl]
excerpt: "Technical setup guide for participating in Jane Street's Advent of FPGA challenge. Covers environment configuration, project structure, and submission requirements."
---

# Advent of FPGA 2025: Setup and Participation Guide

## Challenge Overview

Jane Street's Advent of FPGA challenge requires implementing Advent of Code 2025 puzzles as synthesizable RTL.

**Key Links:**
- [Challenge Announcement](https://blog.janestreet.com/)
- [Submission Form](https://blog.janestreet.com/)
- [Hardcaml Template](https://github.com/janestreet/hardcaml_aoc_template)
- Contact: advent-of-fpga@janestreet.com

## Rules Summary

| Requirement | Details |
|-------------|---------|
| Deadline | January 16, 2026 |
| Minimum submission | 1 puzzle |
| Code | Must be open-sourced |
| RTL languages | Verilog, VHDL, SystemVerilog, Chisel, Amaranth, Filament, Hardcaml |
| Not allowed | HLS (High-Level Synthesis) |
| Originality | No duplicates, no AI-generated submissions, must be able to explain design |

**Submission Requirements:**
1. Source code (open-sourced)
2. Testbench
3. README documenting approach and execution instructions

**Prizes:**
- Top 3 solutions: Zynq UltraScale+ Kria KV260 + Jane Street swag
- Any successful Hardcaml submission: Hardcaml T-shirt

## Evaluation Criteria

Based on the announcement, submissions are evaluated on:

1. **Scalability** — Can the design handle 10×–1000× larger inputs?
2. **Efficiency** — Area/performance trade-offs
3. **Architecture** — Exploitation of FPGA-native parallelism and pipelining
4. **Physical synthesis** — Optional: open-source ASIC flow (e.g., TinyTapeout)
5. **Language features** — Elegant use of HDL capabilities

## Environment Setup

### Option 1: SystemVerilog + Verilator + cocotb

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install -y \
    verilator \
    iverilog \
    gtkwave \
    python3 \
    python3-pip \
    python3-venv \
    build-essential

# Python environment
python3 -m venv venv
source venv/bin/activate
pip install cocotb cocotb-bus pytest numpy
```

Verify installation:
```bash
verilator --version
cocotb-config --version
```

### Option 2: Hardcaml (OCaml)

```bash
# Install opam
sudo apt install opam
opam init -y
opam switch create 5.1.0
eval $(opam env)

# Install Hardcaml
opam install -y hardcaml hardcaml_waveterm hardcaml_verilator

# Clone template
git clone https://github.com/janestreet/hardcaml_aoc_template
cd hardcaml_aoc_template
dune build
```

### Option 3: Vivado (Synthesis Targeting)

Required for accurate resource utilization estimates. Target device for reference: Kria KV260 (Zynq UltraScale+ ZU5EV).

Device resources:
| Resource | Count |
|----------|-------|
| LUTs | 117,120 |
| FFs | 234,240 |
| BRAM (36Kb) | 144 |
| DSP48E2 | 64 |

## Project Structure

```
advent-of-fpga/
├── rtl/
│   ├── common/
│   │   ├── fifo.sv
│   │   ├── arbiter.sv
│   │   ├── ascii_parser.sv
│   │   └── reduction_tree.sv
│   └── puzzles/
│       ├── day01/
│       │   ├── day01_top.sv
│       │   └── day01_pkg.sv
│       ├── day02/
│       └── ...
├── tb/
│   ├── cocotb/
│   │   ├── test_day01.py
│   │   └── ...
│   └── verilator/
├── inputs/
│   ├── day01.txt
│   └── ...
├── sim/
│   └── Makefile
├── synth/
│   ├── vivado/
│   │   └── synth.tcl
│   └── yosys/
├── docs/
│   └── README.md
└── Makefile
```

## Common RTL Components

### ASCII Number Parser

Streams ASCII input and extracts integers:

```systemverilog
module ascii_number_parser #(
    parameter int DATA_WIDTH = 32
)(
    input  logic                  clk,
    input  logic                  rst_n,
    input  logic [7:0]            char_in,
    input  logic                  char_valid,
    input  logic                  char_last,
    output logic [DATA_WIDTH-1:0] number_out,
    output logic                  number_valid,
    output logic                  negative
);

    localparam logic [7:0] CHAR_0     = 8'h30;
    localparam logic [7:0] CHAR_9     = 8'h39;
    localparam logic [7:0] CHAR_MINUS = 8'h2D;
    localparam logic [7:0] CHAR_SPACE = 8'h20;
    localparam logic [7:0] CHAR_NL    = 8'h0A;

    logic [DATA_WIDTH-1:0] accumulator;
    logic                  is_negative;
    logic                  in_number;

    wire is_digit = (char_in >= CHAR_0) && (char_in <= CHAR_9);
    wire is_delim = (char_in == CHAR_SPACE) || (char_in == CHAR_NL) || char_last;
    wire digit_val = char_in - CHAR_0;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            accumulator  <= '0;
            is_negative  <= 1'b0;
            in_number    <= 1'b0;
            number_out   <= '0;
            number_valid <= 1'b0;
            negative     <= 1'b0;
        end else begin
            number_valid <= 1'b0;

            if (char_valid) begin
                if (char_in == CHAR_MINUS && !in_number) begin
                    is_negative <= 1'b1;
                end else if (is_digit) begin
                    in_number   <= 1'b1;
                    accumulator <= (accumulator * 10) + digit_val;
                end else if (is_delim && in_number) begin
                    number_out   <= accumulator;
                    number_valid <= 1'b1;
                    negative     <= is_negative;
                    accumulator  <= '0;
                    is_negative  <= 1'b0;
                    in_number    <= 1'b0;
                end
            end
        end
    end

endmodule
```

### Parameterized Reduction Tree

For sum/min/max operations:

```systemverilog
module reduction_tree #(
    parameter int DATA_WIDTH = 32,
    parameter int NUM_INPUTS = 8,
    parameter string OP = "ADD"  // "ADD", "MIN", "MAX"
)(
    input  logic                  clk,
    input  logic                  rst_n,
    input  logic [DATA_WIDTH-1:0] data_in [NUM_INPUTS],
    input  logic                  valid_in,
    output logic [DATA_WIDTH-1:0] result,
    output logic                  valid_out
);

    localparam int LEVELS = $clog2(NUM_INPUTS);
    
    logic [DATA_WIDTH-1:0] stage [LEVELS+1][NUM_INPUTS];
    logic                  stage_valid [LEVELS+1];

    // Input stage
    always_ff @(posedge clk) begin
        for (int i = 0; i < NUM_INPUTS; i++) begin
            stage[0][i] <= data_in[i];
        end
        stage_valid[0] <= valid_in;
    end

    // Reduction stages
    generate
        for (genvar lvl = 0; lvl < LEVELS; lvl++) begin : gen_levels
            localparam int PAIRS = NUM_INPUTS >> (lvl + 1);
            
            always_ff @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    stage_valid[lvl+1] <= 1'b0;
                end else begin
                    stage_valid[lvl+1] <= stage_valid[lvl];
                    
                    for (int p = 0; p < PAIRS; p++) begin
                        case (OP)
                            "ADD": stage[lvl+1][p] <= stage[lvl][2*p] + stage[lvl][2*p+1];
                            "MIN": stage[lvl+1][p] <= (stage[lvl][2*p] < stage[lvl][2*p+1]) ? 
                                                       stage[lvl][2*p] : stage[lvl][2*p+1];
                            "MAX": stage[lvl+1][p] <= (stage[lvl][2*p] > stage[lvl][2*p+1]) ? 
                                                       stage[lvl][2*p] : stage[lvl][2*p+1];
                        endcase
                    end
                end
            end
        end
    endgenerate

    assign result    = stage[LEVELS][0];
    assign valid_out = stage_valid[LEVELS];

endmodule
```

### Synchronous FIFO

```systemverilog
module sync_fifo #(
    parameter int DATA_WIDTH = 32,
    parameter int DEPTH      = 16,
    parameter int ADDR_WIDTH = $clog2(DEPTH)
)(
    input  logic                  clk,
    input  logic                  rst_n,
    input  logic [DATA_WIDTH-1:0] wr_data,
    input  logic                  wr_en,
    input  logic                  rd_en,
    output logic [DATA_WIDTH-1:0] rd_data,
    output logic                  full,
    output logic                  empty,
    output logic [ADDR_WIDTH:0]   count
);

    logic [DATA_WIDTH-1:0] mem [DEPTH];
    logic [ADDR_WIDTH:0]   wr_ptr, rd_ptr;

    assign full  = (count == DEPTH);
    assign empty = (count == 0);

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            wr_ptr <= '0;
            rd_ptr <= '0;
            count  <= '0;
        end else begin
            if (wr_en && !full) begin
                mem[wr_ptr[ADDR_WIDTH-1:0]] <= wr_data;
                wr_ptr <= wr_ptr + 1;
            end
            
            if (rd_en && !empty) begin
                rd_ptr <= rd_ptr + 1;
            end

            case ({wr_en && !full, rd_en && !empty})
                2'b10:   count <= count + 1;
                2'b01:   count <= count - 1;
                default: count <= count;
            endcase
        end
    end

    assign rd_data = mem[rd_ptr[ADDR_WIDTH-1:0]];

endmodule
```

## cocotb Testbench Template

```python
"""
cocotb testbench template for AoC puzzle
"""
import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, ClockCycles
from pathlib import Path


def parse_input(filepath: Path) -> list:
    """Parse AoC input file - customize per puzzle"""
    with open(filepath) as f:
        return [int(line.strip()) for line in f if line.strip()]


def reference_solution(data: list) -> int:
    """Python reference implementation - customize per puzzle"""
    return sum(data)


class PuzzleDriver:
    def __init__(self, dut):
        self.dut = dut

    async def reset(self):
        self.dut.rst_n.value = 0
        await ClockCycles(self.dut.clk, 5)
        self.dut.rst_n.value = 1
        await ClockCycles(self.dut.clk, 2)

    async def send_data(self, data: list):
        for i, val in enumerate(data):
            self.dut.data_in.value = val
            self.dut.valid_in.value = 1
            self.dut.last_in.value = (i == len(data) - 1)
            await RisingEdge(self.dut.clk)
        self.dut.valid_in.value = 0

    async def wait_result(self, timeout_cycles: int = 1000) -> int:
        for _ in range(timeout_cycles):
            await RisingEdge(self.dut.clk)
            if self.dut.valid_out.value:
                return int(self.dut.result.value)
        raise TimeoutError("DUT did not produce result")


@cocotb.test()
async def test_puzzle_with_sample(dut):
    """Test with sample input"""
    cocotb.start_soon(Clock(dut.clk, 10, units="ns").start())
    
    driver = PuzzleDriver(dut)
    await driver.reset()

    # Sample data - replace with actual sample
    sample_data = [1, 2, 3, 4, 5]
    expected = reference_solution(sample_data)

    await driver.send_data(sample_data)
    result = await driver.wait_result()

    assert result == expected, f"Expected {expected}, got {result}"
    cocotb.log.info(f"Sample test passed: {result}")


@cocotb.test()
async def test_puzzle_with_input(dut):
    """Test with actual puzzle input"""
    cocotb.start_soon(Clock(dut.clk, 10, units="ns").start())
    
    driver = PuzzleDriver(dut)
    await driver.reset()

    input_file = Path(__file__).parent.parent.parent / "inputs" / "day01.txt"
    if not input_file.exists():
        cocotb.log.warning(f"Input file not found: {input_file}")
        return

    data = parse_input(input_file)
    expected = reference_solution(data)

    await driver.send_data(data)
    result = await driver.wait_result()

    assert result == expected, f"Expected {expected}, got {result}"
    cocotb.log.info(f"Puzzle test passed: {result}")
```

## Makefile

```makefile
SIM ?= verilator
TOPLEVEL_LANG ?= verilog

VERILOG_SOURCES += $(PWD)/rtl/common/sync_fifo.sv
VERILOG_SOURCES += $(PWD)/rtl/common/ascii_parser.sv
VERILOG_SOURCES += $(PWD)/rtl/puzzles/day01/day01_top.sv

TOPLEVEL = day01_top
MODULE = tb.cocotb.test_day01

EXTRA_ARGS += --trace --trace-structs

include $(shell cocotb-config --makefiles)/Makefile.sim

.PHONY: synth clean-all waves

synth:
	vivado -mode batch -source synth/vivado/synth.tcl

waves:
	gtkwave dump.vcd &

clean-all: clean
	rm -rf __pycache__ **/__pycache__ *.vcd sim_build/
```

## Synthesis Script (synth/vivado/synth.tcl)

```tcl
# Target: Kria KV260 (ZU5EV)
set part xck26-sfvc784-2LV-c

create_project -in_memory -part $part

read_verilog -sv [glob ../rtl/common/*.sv]
read_verilog -sv [glob ../rtl/puzzles/day01/*.sv]

synth_design -top day01_top -part $part

report_utilization -file reports/utilization.rpt
report_timing_summary -file reports/timing.rpt

write_checkpoint -force outputs/post_synth.dcp
```

## Hardcaml Module Template

```ocaml
open Hardcaml
open Signal

module I = struct
  type 'a t = {
    clock : 'a;
    clear : 'a;
    data_in : 'a [@bits 32];
    valid_in : 'a;
  }
  [@@deriving hardcaml]
end

module O = struct
  type 'a t = {
    result : 'a [@bits 32];
    valid_out : 'a;
  }
  [@@deriving hardcaml]
end

let create (i : _ I.t) =
  let spec = Reg_spec.create ~clock:i.clock ~clear:i.clear () in
  
  let accumulator = 
    reg_fb spec ~width:32 ~f:(fun acc ->
      mux2 i.valid_in (acc +: i.data_in) acc
    )
  in
  
  let valid_out = reg spec ~enable:vdd i.valid_in in
  
  { O.result = accumulator; valid_out }

let () =
  let module Circuit = Circuit.With_interface (I) (O) in
  let circuit = Circuit.create_exn ~name:"day01" create in
  Rtl.print Verilog circuit
```

## Documentation Template (docs/README.md)

```markdown
# Advent of FPGA 2025 — [Your Name]

## Solutions

| Day | Status | Language | LUTs | FFs | BRAM | Fmax (MHz) |
|-----|--------|----------|------|-----|------|------------|
| 01  | ⬜     |          |      |     |      |            |
| 02  | ⬜     |          |      |     |      |            |
| ... |        |          |      |     |      |            |

## Build Instructions

### Prerequisites
- Verilator 5.0+
- Python 3.10+ with cocotb
- (Optional) Vivado 2024.1+
- (Optional) OCaml 5.1+ with Hardcaml

### Running Tests
\`\`\`bash
source venv/bin/activate
make TOPLEVEL=day01_top MODULE=tb.cocotb.test_day01
\`\`\`

### Synthesis
\`\`\`bash
make synth
\`\`\`

## Design Notes

### Day 01
**Approach:**

**Architecture:**

**Resource Usage:**

**Performance:**
```

## Timeline

| Date | Task |
|------|------|
| Dec 19 | Environment setup |
| Dec 20–25 | Puzzle selection and initial implementation |
| Dec 26–Jan 5 | Additional puzzles, Hardcaml port |
| Jan 6–12 | Optimization, synthesis verification |
| Jan 13–15 | Documentation |
| Jan 16 | Submission deadline |

## References

- [Advent of Code 2025](https://adventofcode.com/2025)
- [Hardcaml Documentation](https://github.com/janestreet/hardcaml)
- [cocotb Documentation](https://docs.cocotb.org/)
- [Verilator Manual](https://verilator.org/guide/latest/)
